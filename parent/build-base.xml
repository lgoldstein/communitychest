<?xml version="1.0" encoding="UTF-8"?>
<project name="community-base" default="community-base">
	<description>
		Serves as 'base' inclusion file with common definitions $Rev: 645 $
	</description>

	<!-- root of entire 'Community' project -->
	<dirname property="parent.folder.dir" file="${ant.file}"/>
	<dirname property="community.root.dir" file="${parent.folder.dir}"/>

	<!-- properties files that can be used to override some defaults -->
	<!-- user-specific overrides - not part of version control system -->
	<property name="build.local.properties.filename" value="build.local.properties"/>
	<!-- version control system settings for the specific version -->
	<property name="build.version.properties.filename" value="build.version.properties"/>

	<!-- allow host/version-specific properties to override project defaults ones -->
	<property file="${parent.folder.dir}${file.separator}${build.local.properties.filename}"/>
	<property file="${parent.folder.dir}${file.separator}${build.version.properties.filename}"/>

	<!-- import the environment -->
	<property environment="env"/>
	<!-- detect type of O/S -->
	<condition property="win32.local.shell" value="true" else="false">
		<contains string="${os.name}" substring="windows" casesensitive="false"/>
	</condition>
	<condition property="linux.local.shell" value="true" else="false">
		<isfalse value="${win32.local.shell}"/>
	</condition>

	<!-- base name of all packages generated by the project(s) -->
	<property name="community.base.pkg.name" value="net.community"/>
	<dirname property="jdk.home.location" file="${java.home}" />

	<!-- ######### some Maven related definitions ####### -->
	<property name="maven.base.name" value="maven"/>
	<property name="maven.archiver.sub.folder.name" value="${maven.base.name}-archiver"/>
	<property name="maven.repository.root.folder.name" value=".m2"/>
	<property name="maven.repository.sub.folder.name" value="repository"/>
	<condition property="maven.local.repository.folder"
                           value="${env.M2_REPO}"
                           else="${user.home}${file.separator}${maven.repository.root.folder.name}${file.separator}${maven.repository.sub.folder.name}">
		<isset property="env.M2_REPO"/>
	</condition>
	<property name="maven.settings.file.name" value="settings.xml"/>
	<property name="maven.settings.file.path" value="${user.home}${file.separator}${maven.repository.root.folder.name}${file.separator}${maven.settings.file.name}" />

	<!-- ############ Maven artifacts definitions - equivalent to main POM ########### -->
	<property name="chest.artifact.prefix" value="chest"/>
	<property name="chest.base.group.id" value="${community.base.pkg.name}.${chest.artifact.prefix}"/>
	<property name="chest.base.utils.group.id" value="${chest.base.group.id}.base-utils"/>

	<property name="chest.gui.artifact.prefix" value="${chest.artifact.prefix}-gui"/>
	<property name="chest.gui.base.group.id" value="${chest.base.group.id}.gui"/>

	<property name="chest.web.base.group.id" value="${chest.base.group.id}.web"/>

	<property name="chest.net.artifact.prefix" value="${chest.artifact.prefix}-net"/>
	<property name="chest.net.base.group.id" value="${chest.base.group.id}.net"/>

	<property name="chest.xml.base.group.id" value="${chest.base.group.id}.xml"/>

	<property name="chest.j2ee.artifact.prefix" value="${chest.artifact.prefix}-j2ee"/>
	<property name="chest.j2ee.base.group.id" value="${chest.base.group.id}.j2ee"/>

	<property name="chest.3rd.party.base.group.id" value="${chest.base.group.id}.3rd-party"/>
	<property name="chest.3rd.party.apache.group.id" value="${chest.3rd.party.base.group.id}.apache"/>
	<property name="chest.apache.ant.group.id" value="${chest.3rd.party.apache.group.id}.ant"/>
	<property name="chest.maven.group.id" value="${chest.3rd.party.apache.group.id}.maven"/>
	<property name="chest.3rd.party.jfree.group.id" value="${chest.3rd.party.base.group.id}.jfree"/>

	<property name="apps.base.group.id" value="${community.base.pkg.name}.apps"/>

	<property name="build.mode" value="debug"/>
	<!-- to be used where applicable -->
	<condition property="is.debug.mode" value="true">
		<!-- useful property that can be used in 'if' or 'unless' conditions -->
		<equals arg1="${build.mode}" arg2="debug" casesensitive="false" trim="true"/>
	</condition>

	<!-- some JAVA related definitions -->
	<property name="jdk.dist.home" value="${java.home}"/>
	<property name="jvm.version.prefix" value="${jvm.major.version}.${jvm.minor.version}"/>
	<property name="jvm.version" value="${jvm.version.prefix}.${jvm.release.version}_${jvm.update.version}"/>

	<!-- some community project version related related definitions -->
	<property name="community.major.version" value="${jvm.major.version}"/>
	<property name="community.minor.version" value="${jvm.minor.version}"/>
	<property name="community.version.prefix" value="${community.major.version}.${community.minor.version}"/>
	<property name="community.base.version" value="${community.version.prefix}.${community.release.version}"/>

	<!-- some useful general sub-folders names -->
	<property name="lib.sub.folder.name" value="lib"/>
	<property name="bin.sub.folder.name" value="bin"/>
	<property name="metainf.sub.folder.name" value="META-INF"/>
	<property name="webinf.sub.folder.name" value="WEB-INF"/>
	<!-- default name of manifest file -->
	<property name="manifest.file.name" value="MANIFEST.MF"/>

	<!-- useful file(s) suffixes -->
	<property name="jar.file.suffix" value="jar"/>
	<property name="zip.file.suffix" value="zip"/>
	<property name="war.file.suffix" value="war"/>

	<!-- specific community locations -->
	<!-- target location of ALL generated JAR(s) that are NOT applications -->
	<property name="community.lib.folder" value="${community.root.dir}${file.separator}${lib.sub.folder.name}"/>
	<!-- target location of ALL generated application(s) JAR(s) -->
	<property name="community.bin.folder" value="${community.root.dir}${file.separator}${bin.sub.folder.name}"/>

	<!-- some project specific definitions -->
	<property name="build.sub.folder.name" value="build"/>
	<!-- root of all modules for the sub-project

                        DUMMY DEFINITION - MUST BE OVERRIDDEN BEFORE IMPORTING THIS FILE.
                        MUST CONTAIN THE FOLDER OF THE BUILD.XML FILE FOR THE SPECIFIC
                        SUB-PROJECT
                         -->
	<!-- <dirname property="project.root.dir" file="${ant.file}"/> -->
	<!-- target folder where each module should have its own root sub-folder -->
	<property name="project.build.dir" value="${project.root.dir}${file.separator}${build.sub.folder.name}"/>

	<!-- some useful module(s) sub-folders names -->
	<property name="src.sub.folder.name" value="src"/>
	<property name="target.sub.folder.name" value="target"/>
	<property name="classes.sub.folder.name" value="classes"/>
	<property name="apidocs.sub.folder.name" value="apidocs"/>
	<property name="native.sub.folder.name" value="native"/>
	<property name="test.sub.folder.name" value="test"/>
	<property name="test.classes.sub.folder.name" value="${test.sub.folder.name}-${classes.sub.folder.name}"/>
	<property name="main.sub.folder.name" value="main"/>
	<property name="resources.sub.folder.name" value="resources"/>
	<property name="assembly.sub.folder.name" value="assembly"/>
	<property name="java.sub.folder.name" value="java"/>
	<property name="webapp.sub.folder.name" value="webapp"/>

	<!-- specific module/project relative locations to the build.xml file -->
	<property name="module.main.sub.folder.path" value="${src.sub.folder.name}${file.separator}${main.sub.folder.name}"/>
	<property name="module.java.sub.folder.path" value="${module.main.sub.folder.path}${file.separator}${java.sub.folder.name}"/>
	<property name="module.resources.sub.folder.path" value="${module.main.sub.folder.path}${file.separator}${resources.sub.folder.name}"/>
	<property name="module.assembly.sub.folder.path" value="${module.main.sub.folder.path}${file.separator}${assembly.sub.folder.name}"/>
	<property name="module.webapp.sub.folder.path" value="${module.main.sub.folder.path}${file.separator}${webapp.sub.folder.name}"/>
	<property name="module.webinf.sub.folder.path" value="${module.webapp.sub.folder.path}${file.separator}${webinf.sub.folder.name}"/>

	<!-- root folder of the module(s) files

                             DUMMY DEFINITION - MUST BE OVERRIDDEN BEFORE IMPORTING THIS FILE.
                             MUST CONTAIN THE FOLDER OF THE BUILD.XML FILE FOR THE SPECIFIC MODULE:

                            <dirname property="module.root.folder" file="${ant.file}"/>
                         -->
	<!-- <dirname property="module.root.folder" file="${ant.file}"/> -->

	<!-- specific module/project absolute locations -->
	<property name="module.src.folder" value="${module.root.folder}${file.separator}${src.sub.folder.name}"/>
	<property name="module.main.folder" value="${module.root.folder}${file.separator}${module.main.sub.folder.path}"/>
	<property name="module.java.folder" value="${module.root.folder}${file.separator}${module.java.sub.folder.path}"/>
	<property name="module.resources.folder" value="${module.root.folder}${file.separator}${module.resources.sub.folder.path}"/>
	<property name="module.assembly.folder" value="${module.root.folder}${file.separator}${module.assembly.sub.folder.path}"/>
	<property name="module.webapp.folder" value="${module.root.folder}${file.separator}${module.webapp.sub.folder.path}"/>
	<property name="module.webinf.folder" value="${module.webapp.folder}${file.separator}${webinf.sub.folder.name}"/>

	<!-- base package name for the module

                             DUMMY DEFINITION - MUST BE OVERRIDDEN BEFORE IMPORTING THIS FILE.

                        -->
	<!-- <property name="module.base.target.name" value="error.pkg.name"/> -->
	<!-- useful sub-folder - under which the module's classes and META-INF sub-folder(s) reside -->
	<property name="module.target.folder" value="${module.root.folder}${file.separator}${target.sub.folder.name}"/>
	<!-- folder where generate Java native files should reside -->
	<property name="module.native.folder" value="${module.target.folder}${file.separator}${native.sub.folder.name}"/>
	<!-- folder where compiled Java classes should reside -->
	<property name="module.classes.folder" value="${module.target.folder}${file.separator}${classes.sub.folder.name}"/>
	<property name="module.apidocs.folder" value="${module.target.folder}${file.separator}${apidocs.sub.folder.name}"/>
	<property name="module.metainf.folder" value="${module.target.folder}${file.separator}${metainf.sub.folder.name}"/>
	<property name="module.manifest.file.path" value="${module.metainf.folder}${file.separator}${manifest.file.name}"/>

	<property name="module.target.version" value="${community.base.version}.${module.base.version}"/>

	<property name="module.target.file.name.prefix" value="${community.base.pkg.name}"/>
	<property name="module.target.base.file.name" value="${module.target.file.name.prefix}-${module.base.target.name}"/>
	<property name="module.target.jar.file.name" value="${module.target.base.file.name}.${jar.file.suffix}"/>
	<property name="module.target.jar.file.path" value="${community.lib.folder}${file.separator}${module.target.jar.file.name}"/>

	<property name="module.sources.file.suffix" value="sources"/>
	<property name="module.sources.base.file.name" value="${module.target.base.file.name}-${module.sources.file.suffix}"/>
	<property name="module.sources.zip.file.name" value="${module.sources.base.file.name}.${jar.file.suffix}"/>
	<property name="module.sources.zip.file.path" value="${community.lib.folder}${file.separator}${module.sources.zip.file.name}"/>

	<target name="community-base" unless="skip.community.base.target">
		<!-- Make sure the expected and current JVM version(s) match -->
		<fail message="Mismatched JVM versions: expected=${jvm.version.prefix}/got=${java.specification.version}">
			<condition>
				<not>
					<equals arg1="${jvm.version.prefix}" arg2="${java.specification.version}" trim="true" casesensitive="true"/>
				</not>
			</condition>
		</fail>

		<!-- Make sure the expected and current project version(s) match -->
		<fail message="Mismatched project versions: expected=${community.version.prefix}/got=${java.specification.version}">
			<condition>
				<not>
					<equals arg1="${community.version.prefix}" arg2="${java.specification.version}" trim="true" casesensitive="true"/>
				</not>
			</condition>
		</fail>

		<!-- make sure "lib" dir exists so that the "classpathref" to it will be OK -->
		<mkdir dir="${community.lib.folder}"/>

		<!-- NOTE: creates a build.number file to track subsequent builds -->
		<buildnumber file="${parent.folder.dir}${file.separator}build.number"/>

		<property name="skip.community.base.target" value="true"/>
	</target>

	<!-- some properties that are inherited by sub-ant call(s) -->
	<propertyset id="inherited-sub-ant-props">
		<propertyref name="build.mode"/>
		<propertyref name="build.number"/>
		<propertyref name="skip.community.base.target"/>
	</propertyset>

	<!-- ################## Some useful 'function' targets ################# -->

	<!-- ++++++++++++++++++ compilation +++++++++++++++++++ -->
	<!-- compilation target for general usage - SYNPOSIS:

				<antcall target='compile-java-classes'>
					<param name="compile.classes.src.dir" value="XXX"/>
					<param name="compile.classes.dst.dir" value="YYY"/>
				</antcall>

				Where:
					XXX - source folder of the JAVA sources to compile
					YYY - destination folder for generated CLASS files
			-->
	<!-- some default compilation values unless overridden by command line invocation -->
	<!-- base PATH definition used for compilation and JavaDoc -->
	<path id="community.modules.jars">
		<fileset dir="${community.lib.folder}" excludes="*-${module.sources.file.suffix}.${jar.file.suffix},*.${zip.file.suffix}"/>
	</path>

	<property name="default.classpath.ref.name" value="community.modules.jars"/>
	<property name="javac.classpath.ref.name" value="${default.classpath.ref.name}"/>
	<property name="javac.source.version" value="${jvm.major.version}.${jvm.minor.version}"/>
	<property name="javac.target.version" value="${javac.source.version}"/>
	<property name="compile.verbose" value="no"/>
	<property name="compile.optimize" value="off"/>
	<property name="compile.debug" value="on"/>
	<property name="compile.deprecation" value="off"/>
	<property name="compile.include.ant.runtime" value="false" />

	<target name="compile-java-classes">
		<!-- make sure target folder exists -->
		<mkdir dir="${compile.classes.dst.dir}"/>

		<javac	srcdir="${compile.classes.src.dir}"
					destdir="${compile.classes.dst.dir}"
					debug="${compile.debug}"
					source="${javac.source.version}"
					target="${javac.target.version}"
					verbose="${compile.verbose}"
					includeAntRuntime="${compile.include.ant.runtime}"
					deprecation="${compile.deprecation}"
					optimize="${compile.optimize}">
			<classpath>
				<path refid="${javac.classpath.ref.name}"/>
			</classpath>
			<compilerarg compiler="org.eclipse.jdt.core.JDTCompilerAdapter" line="${ecj.compiler.args}"/>
		</javac>
	</target>

	<!-- default compilation target -->
	<target name="compile-module-classes" depends="community-base" unless="skip.compile.module.classes">
		<antcall target="compile-java-classes">
			<param name="compile.classes.src.dir" value="${module.java.folder}"/>
			<param name="compile.classes.dst.dir" value="${module.classes.folder}"/>
		</antcall>

		<property name="skip.compile.module.classes" value="true"/>
	</target>

	<!-- ++++++++++++++++++ MANIFEST file creation +++++++++++++++++++ -->

	<!-- a helper target for creating a manifest file via ANTCALL task - SYNOPSIS:

				<antcall target='create-mainfest-file'>
					<param name='manifest.file.location' value='xxxxxx'/>
					<param name='manifest.file.version' value='zzzzz'/>
				</antcall>

				Where:
					xxxx - the full (!) path of the target manifest file to create
			-->
	<target name="create-mainfest-file">
		<tstamp>
			<format property="manifest.file.touch.time" pattern="yyyy-MM-dd HH:mm:ss Z"/>
		</tstamp>
		<manifest file="${manifest.file.location}" mode="replace">
			<attribute name="Created-By" value="${user.name}"/>
			<attribute name="Implementation-Vendor" value="Community chest GPL'd - Lyor G."/>
			<attribute name="Implementation-Build-Time" value="${manifest.file.touch.time}"/>
			<attribute name="Implementation-Build-Version" value="${manifest.file.version}"/>
			<attribute name="Implementation-Build-Number" value="${build.number}"/>
			<attribute name="Implementation-JVM-Version" value="${java.vm.version}"/>
			<attribute name="Implementation-Build-Type" value="${build.mode}"/>
			<attribute name="Implementation-Build-Switches" value="Debug=${compile.debug} Deprecation=${compile.deprecation} Optimize=${compile.optimize}"/>
			<attribute name="Implementation-Build-Versions" value="Source=${javac.source.version} Target=${javac.target.version}"/>
			<attribute name="Implementation-OS-Info" value="${os.arch} ${os.name}/${os.version}"/>
		</manifest>
		<echo message="Created: ${manifest.file.location}" level="info"/>
	</target>

	<!-- default manifest creation target -->
	<target name="create-module-manifest-file" depends="community-base" unless="pkg.manifest.build.skip">
		<!-- make sure target folder exists -->
		<mkdir dir="${module.metainf.folder}"/>

		<antcall target="create-mainfest-file">
			<param name="manifest.file.location" value="${module.manifest.file.path}"/>
			<param name="manifest.file.version" value="${module.target.version}"/>
		</antcall>
		<!--
		        <echo message="pkg.manifest.build.skip=${pkg.manifest.build.skip}" level="info"/>
		        -->
	</target>

	<!-- ++++++++++++++++++ MANIFEST file up-to-date checking +++++++++++++++++++ -->

	<!-- checks if need to update the manifest and sets pkg.manifest.build.skip property
			     to TRUE. The conditions are:

				(*) the MANIFEST.MF files exists
			and
			 	(*) nothing was compiled in the classes (compares timestamp with mainfest file)
			and
				(*) all META-INF resources are up-to-date  (compares timestamp with manifest file)
			 -->

	<target name="check-module-manifest-uptodate" depends="community-base" unless="pkg.manifest.build.skip">
		<condition property="pkg.manifest.build.skip" value="true">
			<and>
				<!-- is there a MANIFEST.MF file ? -->
				<available file="${module.manifest.file.path}"/>

				<!-- is there a classes directory ? -->
				<available file="${module.classes.folder}" type="dir"/>

				<!-- check if any of the .class/resource file(s) is newer than the JAR target -->
				<uptodate>
					<srcfiles dir="${module.classes.folder}" includes="**${file.separator}*"/>
					<mapper type="merge" to="${module.manifest.file.path}"/>
				</uptodate>

				<!-- is there a META-INFO folder ? -->
				<available file="${module.metainf.folder}" type="dir"/>

				<!-- check if any of the resource files is newer than the JAR target -->
				<uptodate>
					<srcfiles dir="${module.metainf.folder}"
							  includes="**${file.separator}*"
							  excludes="${manifest.file.name}"/>
					<mapper type="merge" to="${module.manifest.file.path}"/>
				</uptodate>
			</and>
		</condition>
		<!--
                        <echo message="${module.manifest.file.path} - pkg.manifest.build.skip=${pkg.manifest.build.skip}" level="info"/>
                        -->
	</target>

	<!-- ++++++++++++++++++ JAR file up-to-date checking +++++++++++++++++++ -->

	<!-- checks if package JAR should be re-built and sets pkg.jar.build.skip
			     property to TRUE if so. The condition is that the manifest is up-to-date
                             when compared with the JAR file (if it exists).

			     NOTE: the check-module-manifest-uptodate target takes care of checking if
                             the .class files are up-to-date, so if they are not, a more recent MANIFEST.MF
                             file is created, so this target's condition will be satisfied
			-->

	<target name="check-module-target-jar-uptodate" depends="check-module-manifest-uptodate" unless="pkg.jar.build.skip">
		<condition property="pkg.jar.build.skip" value="true">
			<and>
				<available file="${module.target.jar.file.path}"/>
				<isset property="pkg.manifest.build.skip"/>
			</and>
		</condition>
		<!--
                        <echo message="${module.target.jar.file.path} - pkg.jar.build.skip=${pkg.jar.build.skip}" level="info"/>
                        -->
	</target>

	<!-- +++++++++++++++++ Resource COPY(ing) ++++++++++++++++++++++++++ -->
	<!--
                        copies all non-Java/HTML files to the specified target directorry
                     -->
	<property name="pkg.excluded.resources.pattern" value="**/*.java"/>
	<target name="copy-resource-files">
		<copy preservelastmodified="true" todir="${pkg.target.res.location}"  includeEmptyDirs="false" verbose="true">
			<fileset dir="${pkg.source.res.location}" excludes="${pkg.excluded.resources.pattern}"/>
		</copy>
	</target>

	<!-- by default copies all files from the "src/main/resources" location to the "classes" location -->
	<condition property="pkg.copy.main.resources" value="true">
		<available file="${module.resources.folder}" type="dir"/>
	</condition>
	<target name="copy-resources-folder" if="pkg.copy.main.resources">
		<antcall target="copy-resource-files">
			<param name="pkg.source.res.location" value="${module.resources.folder}"/>
			<param name="pkg.target.res.location" value="${module.classes.folder}"/>
		</antcall>
	</target>

	<!-- by default copies all non-Java files from the "src/main/java" location to the "classes" location -->
	<condition property="pkg.copy.java.resources" value="true">
		<available file="${module.java.folder}" type="dir"/>
	</condition>
	<target name="copy-module-resource-files" depends="copy-resources-folder" if="pkg.copy.java.resources">
		<antcall target="copy-resource-files">
			<param name="pkg.source.res.location" value="${module.java.folder}"/>
			<param name="pkg.target.res.location" value="${module.classes.folder}"/>
		</antcall>
	</target>

	<!-- +++++++++++++++++ JAR(ing) ++++++++++++++++++++++++++ -->
	<!--
                         executes only the JAR stage - assumes classes are compiled and ready
                         in the pkg.target.classes.dir location, as well as all the META-INF
                         files in the pkg.jar-manifset.file.path
                      -->
	<property name="module.jar.include.pattern" value="**${file.separator}*"/>
	<property name="module.jar.exclude.pattern" value=""/>

	<property name="module.metainf.include.pattern" value="${metainf.folder.name}${file.separator}**${file.separator}*"/>
	<property name="module.metainf.exclude.pattern" value="${metainf.folder.name}${file.separator}${manifest.file.name}"/>

	<target name="jar-target-files">
		<dirname property="pkg.target.metainf.parent.dir" file="${pkg.jar-manifset.file.path}"/>

		<jar destfile="${pkg.target.jar.location}"
			     manifest="${pkg.jar-manifset.file.path}"
			     update="false"
			     index="true">

			<!-- classes -->
			<fileset dir="${pkg.target.classes.dir}"
                                         includes="${module.jar.include.pattern}"
                                         excludes="${module.jar.exclude.pattern}"
                                         />

			<!-- resources - excluding the MAINFEST.MF itself and any VSS .scc file(s) -->
			<fileset dir="${pkg.target.metainf.parent.dir}"
					 includes="${module.metainf.include.pattern}"
				 	 excludes="${module.metainf.exclude.pattern}"/>
		</jar>
	</target>

	<!-- NOTE: automatically compiles the classes -->
	<target name="jar-module-files" unless="pkg.jar.build.skip"
                        depends="compile-module-classes,
                                 copy-module-resource-files,
                                 check-module-manifest-uptodate,
                                 create-module-manifest-file,
                                 check-module-target-jar-uptodate">
		<antcall target="jar-target-files">
			<param name="pkg.target.classes.dir" value="${module.classes.folder}"/>
			<param name="pkg.target.jar.location" value="${module.target.jar.file.path}"/>
			<param name="pkg.jar-manifset.file.path" value="${module.manifest.file.path}"/>
		</antcall>
	</target>

	<!-- ++++++++++++++++++++++ Sources packaging ++++++++++++++++++++ -->
	<!-- checks if sources are older than their ZIP file - i.e., need to re-zip them -->
	<target name="check-module-sources-uptodate" depends="community-base" unless="pkg.src.zip.build.skip">
		<condition property="pkg.src.zip.build.skip" value="true">
			<and>
				<!-- does the zip file exist ? -->
				<available file="${module.sources.zip.file.path}" type="file"/>

				<!-- is any of the source files newer than its zip ? -->
				<uptodate>
					<srcfiles dir="${module.java.folder}" includes="**${file.separator}*"/>
					<mapper type="merge" to="${module.sources.zip.file.path}"/>
				</uptodate>
			</and>
		</condition>
	</target>

	<target name="zip-module-sources" depends="check-module-sources-uptodate" unless="pkg.src.zip.build.skip">
		<zip destfile="${module.sources.zip.file.path}"
                         duplicate="fail"
                         whenempty="fail"
                         basedir="${module.java.folder}"
                    />
	</target>

	<!-- +++++++++++++++++ Clean-up ++++++++++++++++++++++++++ -->
	<available property="module.target.exists" file="${module.target.folder}" type="dir"/>
	<target name="clean-module-target-intermediate-files" depends="community-base" if="module.target.exists">
		<delete includeemptydirs="true" verbose="show.quiet.delete">
			<fileset dir="${module.target.folder}" includes="**/*"/>
		</delete>
	</target>
	<target name="clean-module-target-build" depends="clean-module-target-intermediate-files">
		<delete file="${module.target.jar.file.path}"/>
		<delete file="${module.sources.zip.file.path}"/>
	</target>

	<!-- +++++++++++++++++ JAR signing ++++++++++++++++++++++++++ -->
	<property name="sign.keystore.folder" value="${parent.folder.dir}"/>
	<property name="sign.keystore.file.name" value="lyor.key"/>
	<property name="sign.keystore.location" value="${sign.keystore.folder}${file.separator}${sign.keystore.file.name}"/>
	<property name="sign.keystore.alias" value="lyorg"/>
	<property name="sign.keystore.password" value="123456"/>
	<property name="sign.keyprivate.password" value="${sign.keystore.password}"/>
	<!-- ############# C++ and Visual Studio related locations and definitions ############ -->

	<property name="include.sub.folder.name" value="include"/>
	<property name="cpp.sub.folder.name" value="cpp"/>
	<property name="module.include.sub.folder.path" value="${module.main.sub.folder.path}${file.separator}${include.sub.folder.name}"/>
	<property name="module.include.folder" value="${module.root.folder}${file.separator}${module.include.sub.folder.path}"/>
	<property name="module.cpp.sub.folder.path" value="${module.main.sub.folder.path}${file.separator}${cpp.sub.folder.name}"/>
	<property name="module.cpp.folder" value="${module.root.folder}${file.separator}${module.cpp.sub.folder.path}"/>

	<property name="cpp.file.suffix" value="cpp"/>
	<property name="header.file.suffix" value="h"/>

	<property name="program.files.dir" value="${env.ProgramFiles}"/>
	<property name="vctools.version" value="10.0" />
	<property name="vctools.parent.dir" value="${program.files.dir}"/>
	<property name="vctools.root.dir" value="${vctools.parent.dir}${file.separator}Microsoft Visual Studio ${vctools.version}${file.separator}VC${file.separator}vcpackages"/>
	<property name="vcbuild.exe.file.name" value="vcbuild.exe"/>
	<property name="vcbuild.exe.file.path" value="${vctools.root.dir}${file.separator}${vcbuild.exe.file.name}"/>

	<property name="vc.solution.file.suffix" value=".sln"/>
	<property name="vc.proj.file.suffix" value=".vcproj"/>
	<property name="vc.architecture.name" value="Win32"/>
	<property name="vc.debug.build.mode" value="Debug"/>
	<property name="vc.release.build.mode" value="Release"/>
	<!-- for a specific mode use the following definition -->
	<!-- property name="vcproj.build.mode" value="${workspace.build.mode}|${vc.debug.build.mode}"/ -->
	<property name="vcproj.build.mode" value="$ALL"/>

	<!-- make sure MS Visual Studio executable exists at specified path -->
	<target name="check-vcbuild-env" unless="skip.vcbuild.env.check">
		<fail message="Missing ${vcbuild.exe.file.path}">
			<condition>
				<not>
					<available file="${vcbuild.exe.file.path}" type="file"/>
				</not>
			</condition>
		</fail>
	</target>
	<!-- ##################### builds the specified workspace/project ###############
	
				SYNPOSIS:
				<antcall target='build-vc-project'>
					<param name="workspace.root.dir" value="YYY/>
					<param name="workspace.build.mode" value="Debug / Release"/>
					<param name="workspace.file.path" value="XXX"/>
				</antcall>
	
				Where:
					workspace.file.path - set to the fully qualified path of the workspace '.dsw' file
			-->
	<target name="build-vc-project" depends="check-vcbuild-env">
		<exec dir="${workspace.root.dir}"
			      executable="${vcbuild.exe.file.path}"
			      failonerror="true">
			<arg value='"${workspace.file.path}" /nocolor "${vcproj.build.mode}"'/>
		</exec>
	</target>

	<property name="vcproj.solution.base.name"
			  value="${module.vcproj.name}32"/>
	<property name="vcproj.solution.file.name"
			  value="${vcproj.solution.base.name}${vc.proj.file.suffix}"/>
	<property name="vcproj.solution.file.path"
			  value="${module.root.folder}${file.separator}${vcproj.solution.file.name}"/>
	<target name="compile-local-products" unless="skip.compile.local.products">
		<antcall target="build-vc-project">
			<param name="workspace.root.dir" value="${module.root.folder}"/>
			<param name="workspace.build.mode" value="${vcproj.build.mode}"/>
			<param name="workspace.file.path" value="${vcproj.solution.file.path}"/>
		</antcall>
	</target>

	<!-- Checks if sources are more recent than the ZIP that is supposed to contain them -->
	<property name="vc.proj.sources.file.path"
                          value="${community.lib.folder}${file.separator}${vcproj.solution.base.name}-${module.sources.file.suffix}.${zip.file.suffix}"/>
	<target name="check-local-products-uptodate" unless="local.products.sources.uptodate">
		<condition property="local.products.sources.uptodate" value="true">
			<and>
				<!-- Target zip file exists -->
				<available file="${vc.proj.sources.file.path}" type="file"/>
				<!-- check if any of the .cpp/.h is newer than the ZIP target -->
				<uptodate>
					<srcfiles dir="${module.include.folder}" includes="**${file.separator}*.${header.file.suffix}"/>
					<srcfiles dir="${module.cpp.folder}" includes="**${file.separator}*.${cpp.file.suffix}"/>
					<mapper type="merge" to="${module.manifest.file.path}"/>
				</uptodate>
			</and>
		</condition>
	</target>

	<target name="publish-local-products-sources"
		        depends="check-local-products-uptodate"
                        unless="local.products.sources.uptodate">
		<zip destfile="${vc.proj.sources.file.path}"
                         duplicate="fail"
                         whenempty="fail"
                         >
			<zipfileset dir="${module.include.folder}" includes="**/*.${header.file.suffix}" prefix="${include.sub.folder.name}"/>
			<zipfileset dir="${module.cpp.folder}" includes="**/*.${cpp.file.suffix}" prefix="${cpp.sub.folder.name}"/>
		</zip>
	</target>

	<target name="build-local-products" depends="compile-local-products,publish-local-products-sources"/>

	<target name="clean-local-products">
		<delete verbose="show.quiet.delete" file="${vc.proj.sources.file.path}"/>
	</target>
</project>
