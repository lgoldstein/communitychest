package net.community.chest.dom.proxy;

import java.lang.reflect.Method;
import java.util.Collection;
import java.util.LinkedList;
import java.util.Map;
import java.util.TreeMap;

import org.w3c.dom.Element;

import net.community.chest.lang.ExceptionUtil;
import net.community.chest.reflect.AttributeAccessor;
import net.community.chest.reflect.AttributeMethodType;
import net.community.chest.reflect.ClassUtil;
import net.community.chest.util.map.ClassNameMap;

/**
 * <P>Copyright 2007 as per GPLv2</P>
 *
 * @param <V> The type of objects being reflected
 * @author Lyor G.
 * @since Dec 10, 2007 1:21:30 PM
 */
public class ReflectiveAttributesProxy<V> extends AbstractReflectiveProxy<V,Method> {
    public String getDuplicateAttributeKey (final String name, final Method m)
    {
        final Class<?>[]    pars=(null == m) ? null : m.getParameterTypes();
        final Class<?>        pType=((null == pars) || (pars.length <= 0)) ? null : pars[0];
        final String        pName=(null == pType) ? null : pType.getSimpleName();
        if ((null == pName) || (pName.length() <= 0))
            return name;

        return name + pName;
    }

    protected Map<String,Method> addDuplicateMethod (final Map<String,Method> oMap, final String name, final Method m)
    {
        Map<String,Method>    sMap=oMap;

        final String    key=getDuplicateAttributeKey(name, m);
        if ((null == key) || (key.length() <= 0))
            return sMap;    // OK, though not recommended

        if (null == sMap)
            sMap = new TreeMap<String,Method>(String.CASE_INSENSITIVE_ORDER);

        final Method    prev=sMap.put(key, m);
        if (prev != null)
            throw new IllegalStateException("addDuplicateMethod(" + name + ") same key=" + key);

        return sMap;
    }
    /**
     * @return TRUE=if found duplicate setter(s) during {@link #extractSettersMap(Class)}
     * processing then use the getter's return type to resolve the correct setter.
     * <B>Note: </B>only <U>one</U> such getter must exist, otherwise an exception will
     * be thrown. If FALSE, the a 'virtual' attribute name is generated by appending
     * the attribute type <U>simple</U> name to the base name
     * @see #addDuplicateMethod(Map, String, Method)
     * using the getter
     */
    public boolean isResolveSetterByGetter ()
    {
        return true;
    }

    private Map<String,Method>    _gettersMap    /* =null */;
    protected Map<String,Method> updateGettersMap (final String attrName, final Method gMethod)
    {
        if ((attrName != null) && (attrName.length() > 0) && (gMethod != null))
        {
            synchronized(this)
            {
                if (null == _gettersMap)
                    _gettersMap = new TreeMap<String, Method>(String.CASE_INSENSITIVE_ORDER);
                _gettersMap.put(attrName, gMethod);
            }
        }

        return _gettersMap;
    }
    /**
     * Called if {@link #isResolveSetterByGetter()} is TRUE
     * @param valsClass The values class
     * @param sMethod The duplicate setter method
     * @return The actual {@link Method} to be used
     */
    protected Method resolveSetterByGetter (final Class<V> valsClass, final Method sMethod)
    {
        final Class<?>[]    pars=sMethod.getParameterTypes();
        if ((null == pars) || (pars.length != 1))
            throw new IllegalStateException("resolveSetterByGetter(" + valsClass.getName() + ")[" + sMethod + "] illegal number of parameters");

        final Class<?>                aType=pars[0];
        // TODO don't rely on the setter parameter type - in case 'boolean' override exists as well as non-boolean
        final AttributeMethodType    mType=ClassUtil.isBooleanCompatible(aType) ? AttributeMethodType.PREDICATE : AttributeMethodType.GETTER;
        final String                aName=AttributeMethodType.SETTER.getPureAttributeName(sMethod),
                                    gName=mType.getAccessorName(aName);

        try
        {
            final Method    gMethod=valsClass.getMethod(gName);
            final Class<?>    gType=gMethod.getReturnType();
            if (Void.TYPE.isAssignableFrom(gType) || Void.class.isAssignableFrom(gType))
                throw new IllegalStateException("resolveSetterByGetter(" + valsClass.getName() + ")[" + gMethod + "] void getter return type");

            // take advantage of the opportunity
            updateGettersMap(aName, gMethod);

            // check if lucky enough to have the correct setter in hand
            if (gType == aType)
                return sMethod;

            return valsClass.getMethod(sMethod.getName(), gType);
        }
        catch(NoSuchMethodException e)
        {
            return null;    // OK if method not found
        }
        catch(Exception e)
        {
            throw ExceptionUtil.toRuntimeException(e);
        }
    }

    protected Map<String,Method> handleDuplicateMethods (final Class<V>                     valsClass,
                                                         final Map<String,Method>            orgMap,
                                                         final Collection<? extends Method>    dups)
    {
        if ((null == dups) || (dups.size() <= 0))
            return orgMap;

        Map<String,Method>    sMap=orgMap;
        if (isResolveSetterByGetter())
        {
            Map<String,Method>    xMap=null;
            for (final Method m : dups)
            {
                final String    name=AttributeMethodType.SETTER.getPureAttributeName(m);
                if ((null == name) || (name.length() <= 0))
                    continue;    // should not happen

                sMap.remove(name);

                if ((xMap != null) && xMap.containsKey(name))
                    continue;    // skip if already handled it

                final Method    sMethod=resolveSetterByGetter(valsClass, m);
                if (null == sMethod)
                    continue;

                if (null == xMap)
                    xMap = new TreeMap<String, Method>(String.CASE_INSENSITIVE_ORDER);
                if (xMap.put(name,sMethod) != null)
                    throw new IllegalStateException("handleDuplicateMethods(" + valsClass.getName() + ")[" + sMethod + "] overrides existing setter");
            }

            if ((xMap != null) && (xMap.size() > 0))
                sMap.putAll(xMap);
        }
        else
        {
            for (final Method m : dups)
            {
                final String    name=AttributeMethodType.SETTER.getPureAttributeName(m);
                if ((null == name) || (name.length() <= 0))
                    continue;    // should not happen

                final Method    last=sMap.remove(name);    // remove the last mapping
                if (last != null)    // if removed something, then re-map it
                    sMap = addDuplicateMethod(sMap, name, last);
                sMap = addDuplicateMethod(sMap, name, m);
            }
        }

        return sMap;
    }

    protected Map<String,Method> extractSettersMap (final Class<V> valsClass)
    {
        /*
         *      Special handling for some setters with same name - we "rename" their
         * attributes to something (hopefully) unique
         */
        final Collection<? extends Method>    sl=AttributeMethodType.getAccessibleSetters(valsClass);
        final int                            numSetters=(null == sl) ? 0 : sl.size();
        if (numSetters <= 0)
            return null;

        Map<String,Method>    sMap=null;
        Collection<Method>    dups=null;
        for (final Method m : sl)
        {
            final String    name=AttributeMethodType.SETTER.getPureAttributeName(m);
            if ((null == name) || (name.length() <= 0))
                continue;    // should not happen

            if (null == sMap)
                sMap = new TreeMap<String,Method>(String.CASE_INSENSITIVE_ORDER);

            final Method    prev=sMap.put(name, m);
            if (prev != null)
            {
                if (null == dups)
                    dups = new LinkedList<Method>();
                dups.add(prev);
            }
        }

        return handleDuplicateMethods(valsClass, sMap, dups);
    }
    /*
     * @see net.community.chest.dom.transform.AbstractReflectiveProxy#extractAccessorsMap(java.lang.Class)
     */
    @Override
    protected Map<String,Method> extractAccessorsMap (Class<V> valsClass)
    {
        return extractSettersMap(valsClass);
    }

    public Map<String,Method> getSettersMap ()
    {
        return getAccessorsMap();
    }

    public void setSettersMap (Map<String,Method> settersMap)
    {
        setAccessorsMap(settersMap);
    }
    /**
     * Automatically ignore {@link Object#getClass()} &quot;attribute&quot;
     */
    public static final String    CLASS_ATTR="class";
    public static final Class<?> loadElementClass (final Element elem) throws Exception
    {
        final String    clsPath=(null == elem) ? null : elem.getAttribute(CLASS_ATTR);
        if ((null == clsPath) || (clsPath.length() <= 0))
            return null;

        return ClassUtil.loadClassByName(clsPath);
    }
    /*
     * @see net.community.chest.dom.proxy.AbstractReflectiveProxy#handleUnknownAttribute(java.lang.Object, java.lang.String, java.lang.String, java.util.Map)
     */
    @Override
    protected V handleUnknownAttribute (V src, String name, String value, Map<String, ? extends Method> accsMap) throws Exception
    {
        if (CLASS_ATTR.equalsIgnoreCase(name))
            return src;

        return super.handleUnknownAttribute(src, name, value, accsMap);
    }

    protected V updateObjectResourceAttribute (final V src, final String aName, final String aValue, final Class<?> t, final Method setter) throws Exception
    {
        final Object    o=loadObjectResourceAttribute(src, aName, aValue, t);
        setter.invoke(src, o);
        return src;
    }

    protected V updateObjectResourceAttribute (final V src, final String aName, final String aValue, final Method setter) throws Exception
    {
        return updateObjectResourceAttribute(src, aName, aValue, AttributeMethodType.SETTER.getAttributeType(setter), setter);
    }

    protected V updateObjectAttribute (final V src, final String aName, final String aValue,
                                       final Class<?>    aType, final Method setter) throws Exception
    {
        final Object    objValue=getObjectAttributeValue(src, aName, aValue, aType);
        setter.invoke(src, objValue);
        return src;
    }
    /*
     * @see net.community.chest.dom.transform.AbstractReflectiveProxy#updateObjectAttribute(java.lang.Object, java.lang.String, java.lang.String, java.lang.reflect.AccessibleObject)
     */
    @Override
    protected V updateObjectAttribute (final V src, final String aName, final String aValue, final Method setter) throws Exception
    {
        final Class<?>[]    pars=(null == setter) ? null : setter.getParameterTypes();
        final Class<?>        aType=((null == pars) || (pars.length != 1)) ? null : pars[0];
        return updateObjectAttribute(src, aName, aValue, aType, setter);
    }
    /*
     * @see net.community.chest.dom.transform.AbstractReflectiveProxy#getAttributeRetriever(java.lang.Object, java.lang.String, java.lang.Class)
     */
    @Override
    public Method getAttributeRetriever (final V src, final String attrName, final Class<?> aType) throws Exception
    {
        if ((null == attrName) || (attrName.length() <= 0) || (null == aType))
            return null;

        Method    gMethod=null;
        synchronized(this)
        {
            if ((gMethod=((null == _gettersMap) || (_gettersMap.size() <= 0)) ? null : _gettersMap.get(attrName)) != null)
                return gMethod;
        }

        Class<?>    vClass=getValuesClass();
        if ((null == vClass) && (src != null))
            vClass = src.getClass();

        if (null == vClass)
            return null;

        final String                aName=AttributeMethodType.getAdjustedAttributeName(attrName);
        final AttributeMethodType    mType=ClassUtil.isBooleanCompatible(aType) ? AttributeMethodType.PREDICATE : AttributeMethodType.GETTER;
        final String                mthName=mType.getAccessorName(aName);
        if (null == (gMethod=vClass.getMethod(mthName)))
            throw new IllegalStateException("getAttributeRetriever(" + attrName + ")[" + aType.getName() + "] no retriever");

        final Class<?>    gType=gMethod.getReturnType();
        if (Void.TYPE.isAssignableFrom(gType) || Void.class.isAssignableFrom(gType))
            throw new IllegalStateException("getAttributeRetriever(" + attrName + ")[" + gMethod + "] void getter return type");

        updateGettersMap(aName, gMethod);
        return gMethod;
    }
    /*
     * @see net.community.chest.dom.transform.AbstractReflectiveProxy#getAttributeValue(java.lang.Object, java.lang.String, java.lang.Class)
     */
    @Override
    public Object getAttributeValue (final V src, final String attrName, final Class<?> aType) throws Exception
    {
        final Method    gm=getAttributeRetriever(src, attrName, aType);
        final Object    o=gm.invoke(src, AttributeAccessor.EMPTY_OBJECTS_ARRAY);
        return o;
    }
    /*
     * @see net.community.chest.dom.transform.AbstractReflectiveProxy#resolveAccessorType(java.lang.reflect.AccessibleObject)
     */
    @Override
    public Class<?> resolveAccessorType (final Method m)
    {
        final Class<?>[]    pars=(null == m) ? null : m.getParameterTypes();
        final Class<?>        pType=((null == pars) || (pars.length != 1)) ? null : pars[0];
        return pType;
    }

    private static ClassNameMap<ReflectiveAttributesProxy<?>>    _proxiesMap    /* =null */;
    public static final synchronized ClassNameMap<ReflectiveAttributesProxy<?>> getRegisteredDefaultProxies ()
    {
        if (null == _proxiesMap)
            _proxiesMap = new ClassNameMap<ReflectiveAttributesProxy<?>>();
        return _proxiesMap;
    }

    public static final ReflectiveAttributesProxy<?> getDefaultClassProxy (
            final Class<?> pc, final Class<?> baseClass)
    {
        final ClassNameMap<? extends ReflectiveAttributesProxy<?>>    pm=
            (null == pc) ? null : getRegisteredDefaultProxies();
        if ((null == pm) || (pm.size() <= 0))
            return null;

        for (Class<?> cc=pc; ; )
        {
            final ReflectiveAttributesProxy<?>    p;
            synchronized(pm)
            {
                if ((p=pm.get(cc)) != null)
                    return p;
            }

            if (null == (cc=cc.getSuperclass()))
                break;    // reached the top

            if (baseClass != null)
            {
                if (!baseClass.isAssignableFrom(cc))
                    break;
            }
        }

        return null;
    }

    public static final ReflectiveAttributesProxy<?> getDefaultClassProxy (
            final Class<?> pc, final Class<?> baseClass, final ReflectiveAttributesProxy<?> defProxy)
    {
        final ReflectiveAttributesProxy<?>    p=getDefaultClassProxy(pc, baseClass);
        if (null == p)
            return defProxy;

        if ((null == defProxy) || (defProxy == p))
            return p;

        // if got different proxy than default, prefer the more specific one
        final Class<?>    ppc=p.getValuesClass(), dpc=defProxy.getValuesClass();
        if (ppc.isAssignableFrom(dpc))    // proxy is "weaker" than default
            return defProxy;

        return p;
    }

    public static final ReflectiveAttributesProxy<?> getDefaultClassProxy (
            final Class<?> pc, final ReflectiveAttributesProxy<?> defProxy)
    {
        return getDefaultClassProxy(pc, null, defProxy);
    }

    public static final ReflectiveAttributesProxy<?> getDefaultClassProxy (final Class<?> pc)
    {
        return getDefaultClassProxy(pc, null, null);
    }

    public static final ReflectiveAttributesProxy<?> getDefaultObjectProxy (
            final Object o, final Class<?> baseClass, final ReflectiveAttributesProxy<?> defProxy)
    {
        return getDefaultClassProxy((null == o) ? null : o.getClass(), baseClass, defProxy);
    }

    public static final ReflectiveAttributesProxy<?> getDefaultObjectProxy (
            final Object o, final Class<?> baseClass)
    {
        return getDefaultObjectProxy(o, baseClass, null);
    }


    public static final ReflectiveAttributesProxy<?> getDefaultObjectProxy (final Object o)
    {
        return getDefaultObjectProxy(o, null);
    }
    /**
     * Registers a default proxy for the values class of the provided proxy
     * @param pc The {@link Class} - ignored if null
     * @param proxy  The {@link ReflectiveAttributesProxy} to register as default
     * (ignored if null)
     * @return Previous registered instance for this class - <code>null</code>
     * if none
     */
    public static final ReflectiveAttributesProxy<?> registerDefaultProxy (final Class<?> pc, final ReflectiveAttributesProxy<?> proxy)
    {
        if ((null == pc) || (null == proxy))
            return null;

        final ClassNameMap<ReflectiveAttributesProxy<?>>    pm=getRegisteredDefaultProxies();
        final ReflectiveAttributesProxy<?>                    prev;
        synchronized(pm)
        {
            prev = pm.put(pc, proxy);
        }

        return prev;
    }
    /**
     * Registers a default proxy for the values class of the provided proxy
     * @param proxy The {@link ReflectiveAttributesProxy} to register as default
     * for its {@link ReflectiveAttributesProxy#getValuesClass()}
     * @return Previous registered instance for this class - <code>null</code>
     * if none
     */
    public static final ReflectiveAttributesProxy<?> registerDefaultProxy (final ReflectiveAttributesProxy<?> proxy)
    {
        return registerDefaultProxy((null == proxy) ? null : proxy.getValuesClass(), proxy);
    }

    public ReflectiveAttributesProxy (Class<V> objClass, boolean registerAsDefault)
        throws IllegalArgumentException, IllegalStateException
    {
        super(objClass, Method.class);

        if (registerAsDefault)
        {
            final ReflectiveAttributesProxy<?>    prev=registerDefaultProxy(objClass, this);
            if (prev != null)
                throw new IllegalStateException("<init>#registerDefaultProxy(" + objClass.getName() + ") previous instance registered:" + prev.getClass().getName());
        }
    }

    public ReflectiveAttributesProxy (Class<V> objClass) throws IllegalArgumentException
    {
        this(objClass, false);
    }
}
